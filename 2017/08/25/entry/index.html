<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>entry | caster zone</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">entry</h1><a id="logo" href="/.">caster zone</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> archives</i></a><a href="/coding/"><i class="fa fa-code"> coding</i></a><a href="/about-me/"><i class="fa fa-user"> about me</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">entry</h1><div class="post-meta">Aug 25, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>entry　是面向客户端的接入程序，相当于反向代理服务器，将客户端的请求下发到　dispather </p>
<p>entry 使用的负载均衡模式</p>
<p>entryctrl -&gt; entrywrk：一个entryctrl 管理多个entrywrk</p>
<h4><span id="entryctrl-的流程">entryctrl 的流程</span></h4><ul>
<li><p>启动初始化</p>
<p>entryctrl 启动之后主要做以下几个初始化操作：</p>
<ol>
<li><p>初始化 ip 池，ip 的分发主要由entryctrl 控制，在 login 的回包里将 ip 带下去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">ectrl_ip_pool_init</span><span class="params">()</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>监听本地的域套接字端口，用于和 entrywrk 之间的通信，监听地址为 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```c</div><div class="line">int ectrl_app_ctrl_sock_init()</div></pre></td></tr></table></figure></p>
</li>
<li><p>初始化 mdbg 接口</p>
</li>
<li><p>根据配置文件启动多个 entrywrk </p>
<p>这里先 kill 掉所有的entrywrk 进程，然后 fork() 一个子进程，在子进程中调用 exev() 来启动entrywrk ，再退出子进程。启动entrywrk 的同时也为每个 entrywrk 启动一个定时器，定时发送 keeplive 心跳包。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> __ectrl_start_app(ectrl_app_st *app)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (app-&gt;path == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> pid = fork();</div><div class="line">    BGOTO(pid != <span class="number">-1</span>);</div><div class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>)    <span class="comment">/* 父进程 */</span></div><div class="line">    &#123;</div><div class="line">        app-&gt;pid = pid;</div><div class="line">        <span class="keyword">return</span> pid;</div><div class="line">    &#125;</div><div class="line">    mstr_pointer2 pargs = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">if</span> (app-&gt;args != <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">char</span> *pbuf = (<span class="keyword">char</span> *)MEM_ALLOC(<span class="built_in">strlen</span>(app-&gt;path) </div><div class="line">                                + <span class="number">2</span> + <span class="built_in">strlen</span>(app-&gt;args));</div><div class="line">        <span class="built_in">sprintf</span>(pbuf, <span class="string">"%s %s"</span>, app-&gt;path, app-&gt;args);</div><div class="line">        moa_split_string(pbuf, <span class="string">' '</span>, &amp;pargs);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    execv(app-&gt;path, pargs);</div><div class="line">    WARNLOG(<span class="string">"!!!execv(%s) failed. err(%d:%s)!!!"</span>, app-&gt;path, errno, strerror(errno));</div><div class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">FAILED:</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>启动log_filter 的功能，这里主要做日志过滤，与主功能无关</p>
</li>
</ol>
</li>
<li><p>等待 entrywrk 连入</p>
</li>
<li><p>处理 entrywrk 的请求</p>
<ol>
<li><figure class="highlight plain"><figcaption><span>entrywrk 的 login 请求，每个entrywrk 启动之后会主动上报自己的存在。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">2. ```SRVOP_ECTRL_KEEPALIVE_RSP```  entrywrk回复的心跳包，用于和 entrywrk 保持联系。</div><div class="line">3. ```SRVOP_ECTRL_UPDATE_IP_POOL_RSP```  ip池更新的请求。</div><div class="line"></div><div class="line">主要理解 login 请求的处理：</div><div class="line"></div><div class="line">​	entryctrl 内部会保存成功上报上来的entrywrk 的信息，当上报上来的 entrywrk 的个数大于1 时，即表示至少有一个entrywrk 可以工作了，此时即可以向客户端开放服务了。具体是根据配置文件中监听两个端口，一个是6800 (tcp) 端口，一个是 440(ssl) 端口。</div><div class="line"></div><div class="line">```c</div><div class="line">int32_t ectrl_user_sock_init(PBEctrlApp *app, ectrl_app_man_st *man)</div></pre></td></tr></table></figure>
</li>
</ol>
<p>当客户端连上来的时候 entryctrl 负责将 connectfd 下发给 entrywrk</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> moasock_cb_result __entry_cb(struct moasock* msock)</div><div class="line">&#123;</div><div class="line">    __ectrl_listen_st *listen_st = moasock_get_pridata(msock);</div><div class="line">    SOCKET fd = dup(moasock_get_fd(msock));</div><div class="line">  	<span class="comment">//复制出 connectfd 然后发送给 entrywrk</span></div><div class="line">    ectrl_man_send_app_ctrl_fd(fd, listen_st-&gt;srvtype, listen_st-&gt;listen_type);</div><div class="line">    moasock_close(msock);</div><div class="line">    <span class="keyword">return</span> MCR_TAKEOVER;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里具体选择发送给哪一个 entrywrk时，只做了一个简单的轮询</p>
<p>具体的发送fd 的请求是 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">```c</div><div class="line">int ectrl_man_send_app_ctrl_fd(SOCKET fd, mh_servertype type, uint32_t listen_type)</div><div class="line">&#123;</div><div class="line">    ectrl_app_man_st *man = NULL;</div><div class="line">    int cnt = 0;</div><div class="line">    if (s_ectrl_man.app_hash == NULL)</div><div class="line">        return -1;</div><div class="line">    sf_hash_search(s_ectrl_man.app_hash, &amp;type, sizeof(type), (void **)&amp;man);</div><div class="line">    if (man == NULL || man-&gt;runing_app &lt;= 0)</div><div class="line">        return -1;</div><div class="line">    do &#123;</div><div class="line">        /* 轮询做业务负载，当连接比较多的时候，轮询基本能达到平均*/</div><div class="line">        man-&gt;poll_index = (man-&gt;poll_index + 1) % man-&gt;n_apps;</div><div class="line">        cnt++;</div><div class="line">    &#125; while (man-&gt;apps[man-&gt;poll_index].status != AS_RUNNING &amp;&amp; cnt &lt; man-&gt;n_apps);</div><div class="line"></div><div class="line">    if (man-&gt;apps[man-&gt;poll_index].status != AS_RUNNING)</div><div class="line">        return -1;</div><div class="line">    return ectrl_app_ctrl_send_fd(&amp;man-&gt;apps[man-&gt;poll_index], fd, listen_type);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<h4><span id="entrywrk-的流程">entrywrk 的流程</span></h4><p>entrywrk 的启动由entryctrl 在第四步完成，启动之后进行初始化：</p>
<ul>
<li><p>初始化</p>
<ol>
<li><p>启动之后第一步就是上报 entryctrl 自己的存在，即主动连接 entryctrl 在初始化步骤2 中监听的本地域套接字地址，并在连接成功之后即发送 login 请求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> moasock_cb_result __ectrl_connect_cb(mserver *msrv, <span class="keyword">int</span> err)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (err == <span class="number">0</span>)</div><div class="line">        __ectrl_login_req(msrv);</div><div class="line">    <span class="keyword">return</span> MCR_GOAHEAD;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在连接的回包里有以下的几种请求：</p>
<figure class="highlight plain"><figcaption><span>login的回包，会做以下几个逻辑：</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- 设置 rsp 里的ip 池</div><div class="line">- 根据 rsp 中是否是 ssl 连接初始化ssl证书</div><div class="line">- 初始化 mdbg 接口</div><div class="line">- 联动 servermap 获取公司和用户的信息</div><div class="line">- 联动 regwrk 模块</div><div class="line">- 联动 oprtmanwrk 模块</div><div class="line"></div><div class="line">```SRVOP_ECTRL_KEEPALIVE_REQ``` 来自 entryctrl 的心跳包</div><div class="line"></div><div class="line">主要与entrywrk保活</div><div class="line"></div><div class="line">```SRVOP_ECTRL_ASSIGN_FD_REQ```  来自 entryctrl 下发的客户端  connectfd</div><div class="line"></div><div class="line">```c</div><div class="line">static int __ectrl_assign_fd(mserver *msrv, PBSrvHead *sh, mpacket *pk)</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span>  <span class="title">usr_sock_attach</span><span class="params">(<span class="keyword">long</span> fd)</span></span></div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __user_stcp_peek_recv(cl_tcp*sock,<span class="keyword">char</span> *buf,<span class="keyword">int</span> nread,<span class="keyword">int</span> err,<span class="keyword">void</span>* data)</div></pre></td></tr></table></figure>
<p>然后是根据 connectfd 的类型是 tcp 还是 ssl 进行不同的初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __user_stcp_peek_recv(cl_tcp *sock, <span class="keyword">char</span> *buf,</div><div class="line">                                     <span class="keyword">int</span> nread, <span class="keyword">int</span> err, <span class="keyword">void</span> *data)</div><div class="line">&#123;</div><div class="line">    SOCKET fd = dup(cl_tcp_fd(sock));</div><div class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (ssl_check_version(fd) ==  SSLVER_NOT_SSL)&#123;</div><div class="line">        ret = user_tcp_init(fd);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        ret = _user_stcp_init(fd); </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="number">0</span>!= ret)&#123;</div><div class="line">        close(fd);</div><div class="line">    &#125;</div><div class="line">    cl_tcp_force_close(sock, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将server attach 到该 fd 上，就可以收到来自客户端的包了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">moasock *msock = moasock_attach(fd, <span class="literal">NULL</span>, __packet_cb, __error_cb, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure>
<p>在attach 之后的 __packet_cb 里才是真的处理客户端的请求逻辑，可以看到有来自 servermap的，oprtman(运营)的，和客户端的 auth ，login，除此之外的包一律扔给 dispather 处理。具体的auth，login 逻辑就不梳理了。</p>
<p>顺便有个疑问，在 __packet_cb  回调里 moasock 里带上了 user 的信息，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> moasock_cb_result __packet_cb(struct moasock *msock, mpacket *pk)</div><div class="line">&#123;</div><div class="line">    user_st *user = (user_st *)moasock_get_pridata(msock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而 user_st 里包括了用户所在的 服务器id 等信息，这里的user_st 应该是在登陆了之后才有的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">user_st</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">	mod_mid 				mmid;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">moasock</span>*         <span class="title">client</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">srvcom</span>*          <span class="title">scom</span>;</span></div><div class="line">    PBAthLoginReq*          login_req;</div><div class="line"></div><div class="line">    lst_head                lst_async_reqs;</div><div class="line">    </div><div class="line">	DOMID					did;</div><div class="line">    PERSONID                pid;</div><div class="line">    <span class="keyword">char</span>*                   login_account;</div><div class="line">    <span class="keyword">uint32_t</span>                flag;</div><div class="line">	<span class="keyword">uint32_t</span>				log_srvop;</div><div class="line">	<span class="keyword">uint64_t</span>				srvid;</div><div class="line">&#125;user_st;</div></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>login 请求的处理：</p>
<p>login 是一系列请求，包含了激活，验证码处理，认证，短信认证，忘记密码，重置密码等等。</p>
<p>login 大致流程：根据用户account读数据库 —-&gt; 验证密码 —–&gt; 根据该用户所在的did 查询公司信息( domain 的信息在servermap  联动库里有) —–&gt;  查到之后使用 domain-&gt;ip 和 domain-&gt;port 去连接 dispather ，并保存在 user_st 里—–&gt; 成功之后使用 PBEntryUserAddrPush 通知 dispather </p>
<p>PS：(domain 的port 就是 domain 的app 下dispather 的port，所以这里可以直连某个服务器上的dispather)</p>
<p>具体参照</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">create_connect_to_dispatcher_by_did</span><span class="params">(user_st *user, DOMID did)</span></span>;</div><div class="line"><span class="keyword">static</span> porttype __get_dispatcher_base_port(<span class="keyword">const</span> srvmpa_domain_st *domain);</div></pre></td></tr></table></figure>
<p>这里的查数据是异步过程，即有登录就查，然后就登录事件放在队列里，当数据库异步回调过来了，就从队列中取出登录信息处理</p>
</li>
</ul>
<p>所以 entry可以看做全局负载均衡器，将来自客户端的请求全部扔到 dispather 处理，而dispather 相当于单机的负载均衡器，将所有扔到该服务器上的请求，转发到各个不同的进程</p>
<p>PS：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">setsockopt(sock, SOL_IP, IP_MTU_DISCOVER, (<span class="keyword">char</span> *)&amp;en, len);</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">* IP_MTU_DISCOVER</span></div><div class="line"><span class="comment">* 参见 linux man page 里设置 MTU 的大小  http://man7.org/linux/man-pages/man7/ip.7.html  </span></div><div class="line"><span class="comment">* IP_MTU_DISCOVER (since Linux 2.2)</span></div><div class="line"><span class="comment">              Set or receive the Path MTU Discovery setting for a socket.</span></div><div class="line"><span class="comment">              When enabled, Linux will perform Path MTU Discovery as defined</span></div><div class="line"><span class="comment">              in RFC 1191 on SOCK_STREAM sockets.  For non-SOCK_STREAM</span></div><div class="line"><span class="comment">              sockets, IP_PMTUDISC_DO forces the don't-fragment flag to be</span></div><div class="line"><span class="comment">              set on all outgoing packets.  It is the user's responsibility</span></div><div class="line"><span class="comment">              to packetize the data in MTU-sized chunks and to do the</span></div><div class="line"><span class="comment">              retransmits if necessary.  The kernel will reject (with</span></div><div class="line"><span class="comment">              EMSGSIZE) datagrams that are bigger than the known path MTU.</span></div><div class="line"><span class="comment">              IP_PMTUDISC_WANT will fragment a datagram if needed according</span></div><div class="line"><span class="comment">              to the path MTU, or will set the don't-fragment flag</span></div><div class="line"><span class="comment">              otherwise.</span></div><div class="line"><span class="comment">* Path MTU discovery is a simple protocol that aims to automatically find the optimal MTU   (Maximum Transmission Unit ) for a TCP connections path. This helps to achieve optimum 		performance and network utilization.</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure>
</div><div class="tags"></div><div class="post-nav"><a href="/2017/08/25/Q&amp;A/" class="pre">Q&amp;A</a><a href="/2017/08/25/mailRFC/" class="next">mailRFC</a></div></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/c/" style="font-size: 15px;">c</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/08/25/Q&A/">Q&A</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/25/entry/">entry</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/25/mailRFC/">mailRFC</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/25/sed/">sed</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/25/内核学习笔记/">内核学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/25/后台开发实践/">后台开发实践</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/25/学习笔记/">学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/25/语法笔记/">语法笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/20/C_Learning/">c 语言陷阱与缺陷</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Links</i></div><ul></ul><a href="https://github.com/Mycaster" title="github" target="_blank">github</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">caster zone.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>